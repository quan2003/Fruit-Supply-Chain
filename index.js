// backend/index.js
const express = require("express");
const { Web3 } = require("web3");
const cors = require("cors");
const bcrypt = require("bcrypt");
const pool = require("./db");
const path = require("path");
const fs = require("fs");
const multer = require("multer");

const app = express();

app.use(express.json({ limit: "50mb" }));
app.use(express.urlencoded({ limit: "50mb", extended: true }));
app.use(cors());

// T·∫°o th∆∞ m·ª•c uploads n·∫øu ch∆∞a t·ªìn t·∫°i
const uploadDir = path.join(__dirname, "uploads");
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
}

// C·∫•u h√¨nh multer ƒë·ªÉ l∆∞u file
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "uploads/");
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + "-" + file.originalname);
  },
});
const upload = multer({ storage: storage });

// K·∫øt n·ªëi v·ªõi Ganache (c·ªïng 8545) - Kh√¥ng c·∫ßn thi·∫øt n·ªØa v√¨ giao d·ªãch s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán t·ª´ frontend
// const web3 = new Web3("http://127.0.0.1:8545");

// Th√¥ng tin contract - Kh√¥ng c·∫ßn thi·∫øt n·ªØa
// const contractAddress = "0x20456308Aef9aF8D43C2f831bF666Fe4451eC36d";
// const contractABI = require("./build/contracts/FruitSupplyChain.json").abi;
// const contract = new web3.eth.Contract(contractABI, contractAddress);

// T√†i kho·∫£n t·ª´ Ganache - Kh√¥ng c·∫ßn thi·∫øt n·ªØa
// const account = "0x33dbE90872BbF0a67692D7B533D57A6c185F42bC";

// Danh s√°ch role h·ª£p l·ªá d·ª±a tr√™n database
const validRoles = [
  "Producer",
  "ThirdParty",
  "DeliveryHub",
  "Customer",
  "Admin",
];

// Middleware ki·ªÉm tra quy·ªÅn - Kh√¥ng c·∫ßn thi·∫øt n·∫øu kh√¥ng s·ª≠ d·ª•ng smart contract
const checkAuth = async (req, res, next) => {
  const userAddress = req.headers["x-ethereum-address"];
  if (!userAddress) {
    return res.status(401).json({ error: "Authentication required" });
  }

  // B·ªè ph·∫ßn ki·ªÉm tra smart contract
  req.userAddress = userAddress;
  next();
};

// ==== ƒêƒÇNG K√ù V√Ä ƒêƒÇNG NH·∫¨P ====

app.post("/register", async (req, res) => {
  const { name, email, password, role } = req.body;

  try {
    if (!name || !email || !password || !role) {
      return res
        .status(400)
        .json({ message: "Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin! üòÖ" });
    }

    if (!validRoles.includes(role)) {
      return res.status(400).json({ message: "Vai tr√≤ kh√¥ng h·ª£p l·ªá! üòÖ" });
    }

    const userExists = await pool.query(
      "SELECT * FROM users WHERE email = $1",
      [email]
    );
    if (userExists.rows.length > 0) {
      return res.status(400).json({ message: "Email ƒë√£ t·ªìn t·∫°i! üòÖ" });
    }

    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(password, saltRounds);

    const newUser = await pool.query(
      "INSERT INTO users (name, email, password, role) VALUES ($1, $2, $3, $4) RETURNING *",
      [name, email, hashedPassword, role]
    );

    res
      .status(201)
      .json({ message: "ƒêƒÉng k√Ω th√†nh c√¥ng! üéâ", user: newUser.rows[0] });
  } catch (error) {
    console.error("L·ªói khi ƒëƒÉng k√Ω:", error);
    res
      .status(500)
      .json({ message: "C√≥ l·ªói x·∫£y ra! Vui l√≤ng th·ª≠ l·∫°i nh√©! üòì" });
  }
});

app.post("/login", async (req, res) => {
  const { email, password, role } = req.body;

  try {
    if (!validRoles.includes(role)) {
      return res.status(400).json({ message: "Vai tr√≤ kh√¥ng h·ª£p l·ªá! üòÖ" });
    }

    const user = await pool.query(
      "SELECT * FROM users WHERE email = $1 AND role = $2",
      [email, role]
    );
    if (user.rows.length === 0) {
      return res
        .status(400)
        .json({ message: "Th√¥ng tin ƒëƒÉng nh·∫≠p kh√¥ng ƒë√∫ng! üòÖ" });
    }

    const validPassword = await bcrypt.compare(password, user.rows[0].password);
    if (!validPassword) {
      return res
        .status(400)
        .json({ message: "Th√¥ng tin ƒëƒÉng nh·∫≠p kh√¥ng ƒë√∫ng! üòÖ" });
    }

    res.status(200).json({
      message: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng! üéâ",
      user: {
        id: user.rows[0].id, // Th√™m id ƒë·ªÉ s·ª≠ d·ª•ng trong getInventory
        name: user.rows[0].name,
        email: user.rows[0].email,
        role: user.rows[0].role,
        walletAddress: user.rows[0].wallet_address,
      },
    });
  } catch (error) {
    console.error("L·ªói khi ƒëƒÉng nh·∫≠p:", error);
    res
      .status(500)
      .json({ message: "C√≥ l·ªói x·∫£y ra! Vui l√≤ng th·ª≠ l·∫°i nh√©! üòì" });
  }
});

app.post("/update-wallet", async (req, res) => {
  const { email, walletAddress } = req.body;

  try {
    if (!walletAddress) {
      return res
        .status(400)
        .json({ message: "Vui l√≤ng cung c·∫•p ƒë·ªãa ch·ªâ v√≠! üòÖ" });
    }

    const walletExists = await pool.query(
      "SELECT * FROM users WHERE wallet_address = $1 AND email != $2",
      [walletAddress, email]
    );
    if (walletExists.rows.length > 0) {
      return res
        .status(400)
        .json({ message: "ƒê·ªãa ch·ªâ v√≠ ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng! üòÖ" });
    }

    const updatedUser = await pool.query(
      "UPDATE users SET wallet_address = $1 WHERE email = $2 RETURNING *",
      [walletAddress, email]
    );
    if (updatedUser.rows.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng! üòÖ" });
    }

    res.status(200).json({ message: "C·∫≠p nh·∫≠t v√≠ MetaMask th√†nh c√¥ng! üéâ" });
  } catch (error) {
    console.error("L·ªói khi c·∫≠p nh·∫≠t v√≠:", error);
    res
      .status(500)
      .json({ message: "C√≥ l·ªói x·∫£y ra! Vui l√≤ng th·ª≠ l·∫°i nh√©! üòì" });
  }
});

// ==== L·∫§Y FARM C·ª¶A PRODUCER ====

app.get("/farms/user", async (req, res) => {
  const { email } = req.query;

  try {
    if (!email) {
      return res.status(400).json({ message: "Vui l√≤ng cung c·∫•p email! üòÖ" });
    }

    const user = await pool.query(
      "SELECT id FROM users WHERE email = $1 AND role = 'Producer'",
      [email]
    );
    if (user.rows.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng! üòÖ" });
    }

    const producerId = user.rows[0].id;
    const farms = await pool.query(
      "SELECT * FROM farms WHERE producer_id = $1",
      [producerId]
    );

    res.json(farms.rows);
  } catch (error) {
    console.error("L·ªói khi l·∫•y farm:", error);
    res
      .status(500)
      .json({ message: "C√≥ l·ªói x·∫£y ra! Vui l√≤ng th·ª≠ l·∫°i nh√©! üòì" });
  }
});

// ==== API L·∫§Y DANH S√ÅCH FARMS ====

app.get("/farms", async (req, res) => {
  try {
    const result = await pool.query("SELECT * FROM farms");
    res.json(result.rows);
  } catch (error) {
    console.error("Error fetching farms:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

// ==== API L·∫§Y FARM THEO ID ====

app.get("/farms/:id", async (req, res) => {
  const farmId = req.params.id;

  try {
    const result = await pool.query("SELECT * FROM farms WHERE id = $1", [
      farmId,
    ]);
    if (result.rows.length === 0) {
      return res.status(404).json({ message: "Farm not found" });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error("Error fetching farm:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

// ==== API L·∫§Y DANH S√ÅCH USERS ====

app.get("/users", async (req, res) => {
  try {
    const result = await pool.query("SELECT * FROM users");
    res.json(result.rows);
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

// ==== API L·∫§Y USER THEO ID ====

app.get("/users/:id", async (req, res) => {
  const userId = req.params.id;

  try {
    const result = await pool.query("SELECT * FROM users WHERE id = $1", [
      userId,
    ]);
    if (result.rows.length === 0) {
      return res.status(404).json({ message: "User not found" });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error("Error fetching user:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

// ==== API MUA S·∫¢N PH·∫®M (GIAO D·ªäCH BLOCKCHAIN ƒê∆Ø·ª¢C CHUY·ªÇN SANG FRONTEND) ====

app.post("/purchase-product", async (req, res) => {
  const { productId, buyerAddress, quantity } = req.body;

  try {
    console.log("Received purchase request:", {
      productId,
      buyerAddress,
      quantity,
    });

    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!productId || !buyerAddress || !quantity) {
      console.log("Missing required fields");
      return res
        .status(400)
        .json({ message: "Vui l√≤ng cung c·∫•p ƒë·∫ßy ƒë·ªß th√¥ng tin! üòÖ" });
    }

    // L·∫•y th√¥ng tin s·∫£n ph·∫©m
    console.log("Fetching product with ID:", productId);
    const productResult = await pool.query(
      "SELECT * FROM products WHERE id = $1",
      [productId]
    );
    if (productResult.rows.length === 0) {
      console.log("Product not found");
      return res.status(404).json({ message: "S·∫£n ph·∫©m kh√¥ng t·ªìn t·∫°i! üòÖ" });
    }
    const product = productResult.rows[0];
    console.log("Product found:", product);

    // L·∫•y th√¥ng tin farm c·ªßa s·∫£n ph·∫©m
    console.log("Fetching farm with ID:", product.farm_id);
    const farmResult = await pool.query("SELECT * FROM farms WHERE id = $1", [
      product.farm_id,
    ]);
    if (farmResult.rows.length === 0) {
      console.log("Farm not found");
      return res.status(404).json({ message: "N√¥ng tr·∫°i kh√¥ng t·ªìn t·∫°i! üòÖ" });
    }
    const farm = farmResult.rows[0];
    console.log("Farm found:", farm);

    // L·∫•y th√¥ng tin ng∆∞·ªùi b√°n (producer)
    console.log("Fetching producer with ID:", farm.producer_id);
    const producerResult = await pool.query(
      "SELECT * FROM users WHERE id = $1 AND role = 'Producer'",
      [farm.producer_id]
    );
    if (producerResult.rows.length === 0) {
      console.log("Producer not found");
      return res.status(404).json({ message: "Ng∆∞·ªùi b√°n kh√¥ng t·ªìn t·∫°i! üòÖ" });
    }
    const producer = producerResult.rows[0];
    console.log("Producer found:", producer);

    // L·∫•y th√¥ng tin ƒë·∫°i l√Ω (buyer)
    console.log("Fetching buyer with wallet address:", buyerAddress);
    const buyerResult = await pool.query(
      "SELECT * FROM users WHERE wallet_address = $1 AND role = 'DeliveryHub'",
      [buyerAddress]
    );
    if (buyerResult.rows.length === 0) {
      console.log("Buyer not found");
      return res.status(404).json({ message: "ƒê·∫°i l√Ω kh√¥ng t·ªìn t·∫°i! üòÖ" });
    }
    const buyer = buyerResult.rows[0];
    console.log("Buyer found:", buyer);

    // T√≠nh t·ªïng s·ªë ti·ªÅn (gi√° s·∫£n ph·∫©m * s·ªë l∆∞·ª£ng)
    const totalPrice = product.price * quantity;
    const totalPriceInWei = (
      BigInt(Math.round(totalPrice * 100)) * BigInt(10 ** 16)
    ).toString(); // Chuy·ªÉn ƒë·ªïi sang Wei (1 ETH = 10^18 Wei, gi√° t√≠nh b·∫±ng AGT)
    console.log("Total price in Wei:", totalPriceInWei);

    // Tr·∫£ v·ªÅ th√¥ng tin ƒë·ªÉ frontend th·ª±c hi·ªán giao d·ªãch blockchain
    res.status(200).json({
      message:
        "Th√¥ng tin giao d·ªãch ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n. Vui l√≤ng th·ª±c hi·ªán giao d·ªãch t·ª´ v√≠ MetaMask.",
      totalPriceInWei: totalPriceInWei,
      producerAddress: producer.wallet_address,
      deliveryHubId: buyer.id,
      productId: product.id,
      quantity: quantity,
      price: product.price,
    });
  } catch (error) {
    console.error("Error processing purchase request:", error);
    res
      .status(500)
      .json({ error: "Internal Server Error", details: error.message });
  }
});

// ==== API L·∫§Y DANH S√ÅCH KHO C·ª¶A ƒê·∫†I L√ù ====

app.get("/inventory/:deliveryHubId", async (req, res) => {
  const deliveryHubId = req.params.deliveryHubId;

  try {
    console.log(`Fetching inventory for deliveryHubId: ${deliveryHubId}`); // Th√™m log ƒë·ªÉ debug

    const result = await pool.query(
      "SELECT i.*, p.name, p.productcode, p.imageurl, p.description, p.productdate AS product_productdate, p.expirydate AS product_expirydate FROM inventory i JOIN products p ON i.product_id = p.id WHERE i.delivery_hub_id = $1",
      [deliveryHubId]
    );

    console.log(`Inventory query result: ${JSON.stringify(result.rows)}`); // Th√™m log ƒë·ªÉ ki·ªÉm tra d·ªØ li·ªáu tr·∫£ v·ªÅ

    // X·ª≠ l√Ω d·ªØ li·ªáu tr·∫£ v·ªÅ: ∆∞u ti√™n productdate v√† expirydate t·ª´ inventory, n·∫øu kh√¥ng c√≥ th√¨ l·∫•y t·ª´ products
    const inventoryData = result.rows.map((item) => ({
      ...item,
      productdate: item.productdate || item.product_productdate,
      expirydate: item.expirydate || item.product_expirydate,
    }));

    res.json(inventoryData);
  } catch (error) {
    console.error("Error fetching inventory:", error);
    res
      .status(500)
      .json({ error: "Internal Server Error", details: error.message });
  }
});

// ==== API C·∫¨P NH·∫¨T GI√Å S·∫¢N PH·∫®M TRONG KHO ====

app.put("/inventory/:inventoryId/price", async (req, res) => {
  const inventoryId = req.params.inventoryId;
  const { newPrice } = req.body;

  try {
    if (!newPrice || newPrice <= 0) {
      return res.status(400).json({ message: "Gi√° m·ªõi kh√¥ng h·ª£p l·ªá! üòÖ" });
    }

    const result = await pool.query(
      "UPDATE inventory SET price = $1 WHERE id = $2 RETURNING *",
      [newPrice, inventoryId]
    );
    if (result.rows.length === 0) {
      return res
        .status(404)
        .json({ message: "S·∫£n ph·∫©m trong kho kh√¥ng t·ªìn t·∫°i! üòÖ" });
    }

    res.status(200).json({
      message: "C·∫≠p nh·∫≠t gi√° th√†nh c√¥ng!",
      inventoryItem: result.rows[0],
    });
  } catch (error) {
    console.error("Error updating price:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

// ==== API ƒê∆ØA S·∫¢N PH·∫®M L√äN B√ÅN CHO NG∆Ø·ªúI TI√äU D√ôNG ====

app.post("/sell-product", async (req, res) => {
  const { inventoryId, quantity } = req.body;

  try {
    // Ki·ªÉm tra d·ªØ li·ªáu ƒë·∫ßu v√†o
    if (!inventoryId || !quantity || quantity <= 0) {
      return res
        .status(400)
        .json({ message: "Vui l√≤ng cung c·∫•p ƒë·∫ßy ƒë·ªß th√¥ng tin! üòÖ" });
    }

    // L·∫•y th√¥ng tin s·∫£n ph·∫©m trong kho
    const inventoryResult = await pool.query(
      "SELECT * FROM inventory WHERE id = $1",
      [inventoryId]
    );
    if (inventoryResult.rows.length === 0) {
      return res
        .status(404)
        .json({ message: "S·∫£n ph·∫©m trong kho kh√¥ng t·ªìn t·∫°i! üòÖ" });
    }
    const inventoryItem = inventoryResult.rows[0];

    // Ki·ªÉm tra s·ªë l∆∞·ª£ng
    if (inventoryItem.quantity < quantity) {
      return res
        .status(400)
        .json({ message: "S·ªë l∆∞·ª£ng trong kho kh√¥ng ƒë·ªß! üòÖ" });
    }

    // Th√™m s·∫£n ph·∫©m v√†o danh s√°ch b√°n (outgoing_products)
    const outgoingResult = await pool.query(
      "INSERT INTO outgoing_products (product_id, delivery_hub_id, quantity, price, listed_date, status) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, 'Available') RETURNING *",
      [
        inventoryItem.product_id,
        inventoryItem.delivery_hub_id,
        quantity,
        inventoryItem.price,
      ]
    );

    // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng trong kho
    const newQuantity = inventoryItem.quantity - quantity;
    if (newQuantity === 0) {
      await pool.query("DELETE FROM inventory WHERE id = $1", [inventoryId]);
    } else {
      await pool.query("UPDATE inventory SET quantity = $1 WHERE id = $2", [
        newQuantity,
        inventoryId,
      ]);
    }

    res.status(200).json({
      message: "S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c ƒë∆∞a l√™n b√°n th√†nh c√¥ng!",
      outgoingProduct: outgoingResult.rows[0],
    });
  } catch (error) {
    console.error("Error selling product:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

// ==== API L·∫§Y DANH S√ÅCH S·∫¢N PH·∫®M ƒêANG B√ÅN ====

app.get("/outgoing-products/:deliveryHubId", async (req, res) => {
  const deliveryHubId = req.params.deliveryHubId;

  try {
    const result = await pool.query(
      "SELECT op.*, p.name, p.productcode, p.imageurl, p.description FROM outgoing_products op JOIN products p ON op.product_id = p.id WHERE op.delivery_hub_id = $1 AND op.status = 'Available'",
      [deliveryHubId]
    );
    res.json(result.rows);
  } catch (error) {
    console.error("Error fetching outgoing products:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

// ==== API TH√äM S·∫¢N PH·∫®M V√ÄO KHO SAU KHI GIAO D·ªäCH TH√ÄNH C√îNG ====

app.post("/add-to-inventory", async (req, res) => {
  const { productId, deliveryHubId, quantity, price, productdate, expirydate } =
    req.body;

  try {
    console.log("Adding to inventory:", {
      productId,
      deliveryHubId,
      quantity,
      price,
      productdate,
      expirydate,
    });

    // Ki·ªÉm tra c√°c tr∆∞·ªùng b·∫Øt bu·ªôc
    if (!productId || !deliveryHubId || !quantity || !price) {
      return res
        .status(400)
        .json({ message: "Vui l√≤ng cung c·∫•p ƒë·∫ßy ƒë·ªß th√¥ng tin! üòÖ" });
    }

    // G√°n gi√° tr·ªã m·∫∑c ƒë·ªãnh cho productdate v√† expirydate n·∫øu kh√¥ng c√≥
    const defaultProductDate = productdate || new Date().toISOString();
    const defaultExpiryDate =
      expirydate ||
      new Date(new Date().setMonth(new Date().getMonth() + 1)).toISOString();

    const inventoryResult = await pool.query(
      "INSERT INTO inventory (product_id, delivery_hub_id, quantity, price, productdate, expirydate, received_date) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP) RETURNING *",
      [
        productId,
        deliveryHubId,
        quantity,
        price,
        defaultProductDate,
        defaultExpiryDate,
      ]
    );
    console.log("Inventory item added:", inventoryResult.rows[0]);

    res.status(200).json({
      message: "S·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c th√™m v√†o kho.",
      inventoryItem: inventoryResult.rows[0],
    });
  } catch (error) {
    console.error("Error adding to inventory:", error);
    res
      .status(500)
      .json({ error: "Internal Server Error", details: error.message });
  }
});

// ==== DANH M·ª§C TR√ÅI C√ÇY ====

app.post("/catalog", checkAuth, async (req, res) => {
  const {
    fruitType,
    description,
    growingSeason,
    nutritionalValue,
    storageConditions,
    commonVarieties,
  } = req.body;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract
    res.json({ message: "Fruit catalog added", fruitType });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get("/catalog/:fruitType", async (req, res) => {
  const fruitType = req.params.fruitType;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract, tr·∫£ v·ªÅ d·ªØ li·ªáu gi·∫£ l·∫≠p
    res.json({
      name: fruitType,
      description: "M√¥ t·∫£ gi·∫£ l·∫≠p",
      growingSeason: "M√πa h√®",
      nutritionalValue: "Gi√†u vitamin C",
      storageConditions: "B·∫£o qu·∫£n ·ªü nhi·ªát ƒë·ªô m√°t",
      commonVarieties: ["Gi·ªëng 1", "Gi·ªëng 2"],
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get("/catalogs", async (req, res) => {
  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract, tr·∫£ v·ªÅ d·ªØ li·ªáu gi·∫£ l·∫≠p
    res.json({ fruitTypes: ["B∆∞·ªüi", "Xo√†i", "Thanh Long"] });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==== N√îNG TR·∫†I ====

app.post("/farm", async (req, res) => {
  const { farmId, location, climate, soil, currentConditions, email } =
    req.body;

  try {
    if (
      !farmId ||
      !location ||
      !climate ||
      !soil ||
      !currentConditions ||
      !email
    ) {
      return res
        .status(400)
        .json({ message: "Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin! üòÖ" });
    }

    const user = await pool.query(
      "SELECT id FROM users WHERE email = $1 AND role = 'Producer'",
      [email]
    );
    if (user.rows.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng! üòÖ" });
    }

    const producerId = user.rows[0].id;

    const validQualities = [
      "N·∫Øng",
      "M∆∞a",
      "Kh√¥ hanh",
      "·∫®m ∆∞·ªõt",
      "S∆∞∆°ng m√π",
      "Gi√≥ m·∫°nh",
    ];
    let quality = "N·∫Øng";
    for (const validQuality of validQualities) {
      if (currentConditions.includes(validQuality)) {
        quality = validQuality;
        break;
      }
    }

    const newFarm = await pool.query(
      "INSERT INTO farms (producer_id, farm_name, location, weather_condition, yield, quality, current_conditions) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *",
      [producerId, farmId, location, climate, 0, quality, currentConditions]
    );

    res.json({ message: "Farm registered", farmId: newFarm.rows[0].id });
  } catch (error) {
    console.error("L·ªói khi t·∫°o farm:", error);
    res
      .status(500)
      .json({ message: "C√≥ l·ªói x·∫£y ra! Vui l√≤ng th·ª≠ l·∫°i nh√©! üòì" });
  }
});

app.put("/farm/:farmId", async (req, res) => {
  const farmId = req.params.farmId;
  const { conditions } = req.body;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract
    res.json({ message: "Farm conditions updated", farmId });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get("/farm/:farmId", async (req, res) => {
  const farmId = req.params.farmId;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract, tr·∫£ v·ªÅ d·ªØ li·ªáu t·ª´ database
    const farm = await pool.query("SELECT * FROM farms WHERE id = $1", [
      farmId,
    ]);
    if (farm.rows.length === 0) {
      return res.status(404).json({ message: "Farm not found" });
    }
    res.json(farm.rows[0]);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get("/farms", async (req, res) => {
  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract, tr·∫£ v·ªÅ d·ªØ li·ªáu t·ª´ database
    const farms = await pool.query("SELECT * FROM farms");
    res.json(farms.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==== TR√ÅI C√ÇY ====

app.post("/harvest", async (req, res) => {
  const { fruitType, origin, farmId, quality } = req.body;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract
    res.json({ message: "Fruit harvested", fruitId: "1" });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post("/record-step", async (req, res) => {
  const { fruitId, step } = req.body;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract
    res.json({ message: `Step ${step} recorded` });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post("/recommendation", checkAuth, async (req, res) => {
  const { fruitId, recommendation } = req.body;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract
    res.json({ message: "Recommendation added", fruitId });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get("/fruit/:id", async (req, res) => {
  const fruitId = req.params.id;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract, tr·∫£ v·ªÅ d·ªØ li·ªáu gi·∫£ l·∫≠p
    res.json({
      fruitType: "B∆∞·ªüi",
      origin: "T·ªânh Th√°i Nguy√™n",
      producer: "nguoi dan",
      history: ["Harvested", "Processed"],
      harvestDate: new Date().toISOString(),
      quality: "N·∫Øng",
      recommendations: ["B·∫£o qu·∫£n ·ªü nhi·ªát ƒë·ªô m√°t"],
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==== QU·∫¢N L√ù H·ªÜ TH·ªêNG ====

app.post("/manager", checkAuth, async (req, res) => {
  const { address } = req.body;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract
    res.json({ message: "Manager added", address });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.delete("/manager/:address", checkAuth, async (req, res) => {
  const address = req.params.address;

  try {
    // B·ªè ph·∫ßn s·ª≠ d·ª•ng smart contract
    res.json({ message: "Manager removed", address });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==== PH√ÇN T√çCH D·ªÆ LI·ªÜU ====

app.get("/analytics/trends", async (req, res) => {
  try {
    res.json({
      popularFruits: ["Xo√†i", "Thanh Long", "Chu·ªëi"],
      growingRegions: {
        "ƒê·ªìng b·∫±ng s√¥ng C·ª≠u Long": ["Xo√†i", "S·∫ßu ri√™ng", "Chu·ªëi"],
        "T√¢y Nguy√™n": ["B∆°", "Thanh Long"],
        "Mi·ªÅn Trung": ["Thanh Long", "D·ª©a"],
      },
      qualityTrends: {
        Xo√†i: "TƒÉng",
        "Thanh Long": "Gi·∫£m nh·∫π",
        Chu·ªëi: "·ªîn ƒë·ªãnh",
      },
      recommendations: [
        "N√™n ƒë·∫ßu t∆∞ v√†o tr·ªìng Xo√†i t·∫°i ƒê·ªìng b·∫±ng s√¥ng C·ª≠u Long",
        "C·∫ßn c·∫£i thi·ªán k·ªπ thu·∫≠t canh t√°c Thanh Long t·∫°i Mi·ªÅn Trung",
        "Th·ªã tr∆∞·ªùng B∆° c√≥ ti·ªÅm nƒÉng ph√°t tri·ªÉn cao",
      ],
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==== S·∫¢N PH·∫®M ====

app.get("/products", async (req, res) => {
  const { email } = req.query;

  try {
    if (email) {
      // N·∫øu c√≥ email, l·ªçc s·∫£n ph·∫©m theo producer
      const user = await pool.query(
        "SELECT id FROM users WHERE email = $1 AND role = 'Producer'",
        [email]
      );
      if (user.rows.length === 0) {
        return res
          .status(404)
          .json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng! üòÖ" });
      }
      const producerId = user.rows[0].id;

      const farms = await pool.query(
        "SELECT id FROM farms WHERE producer_id = $1",
        [producerId]
      );
      const farmIds = farms.rows.map((farm) => farm.id);

      if (farmIds.length === 0) {
        return res.json([]);
      }

      const result = await pool.query(
        "SELECT * FROM products WHERE farm_id = ANY($1)",
        [farmIds]
      );
      res.json(result.rows);
    } else {
      // N·∫øu kh√¥ng c√≥ email, l·∫•y t·∫•t c·∫£ s·∫£n ph·∫©m
      const result = await pool.query("SELECT * FROM products");
      res.json(result.rows);
    }
  } catch (error) {
    console.error("Error fetching products:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

app.get("/products/:id", async (req, res) => {
  try {
    const result = await pool.query("SELECT * FROM products WHERE id = $1", [
      req.params.id,
    ]);
    if (result.rows.length === 0) {
      return res.status(404).json({ message: "Product not found" });
    }
    res.json(result.rows[0]);
  } catch (error) {
    console.error("Error fetching product:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

app.post("/products", upload.single("image"), async (req, res) => {
  console.log("D·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c t·ª´ frontend:", req.body, req.file);

  const {
    name,
    productcode,
    category,
    description,
    price,
    quantity,
    productdate,
    expirydate,
    farm_id,
    email, // Th√™m email ƒë·ªÉ ki·ªÉm tra producer
  } = req.body;
  const image = req.file;

  try {
    if (
      !name ||
      !productcode ||
      !category ||
      !description ||
      !price ||
      !quantity ||
      !productdate ||
      !expirydate ||
      !farm_id ||
      !image ||
      !email
    ) {
      return res
        .status(400)
        .json({ message: "Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin! üòÖ" });
    }

    // Ki·ªÉm tra producer
    const user = await pool.query(
      "SELECT id FROM users WHERE email = $1 AND role = 'Producer'",
      [email]
    );
    if (user.rows.length === 0) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng! üòÖ" });
    }
    const producerId = user.rows[0].id;

    // Ki·ªÉm tra farm c√≥ thu·ªôc producer kh√¥ng
    const farm = await pool.query(
      "SELECT * FROM farms WHERE id = $1 AND producer_id = $2",
      [farm_id, producerId]
    );
    if (farm.rows.length === 0) {
      return res
        .status(400)
        .json({ message: "Farm kh√¥ng thu·ªôc producer n√†y! üòÖ" });
    }

    const imageUrl = `/uploads/${image.filename}`;

    const result = await pool.query(
      "INSERT INTO products (name, productcode, category, description, price, quantity, imageurl, productdate, expirydate, farm_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) RETURNING *",
      [
        name,
        productcode,
        category,
        description,
        price,
        quantity,
        imageUrl,
        productdate,
        expirydate,
        farm_id,
      ]
    );
    res.status(201).json(result.rows[0]);
  } catch (error) {
    console.error("Error saving product to database:", error);
    res.status(500).json({ error: "Internal Server Error" });
  }
});

// Ph·ª•c v·ª• file tƒ©nh t·ª´ th∆∞ m·ª•c uploads
app.use("/uploads", express.static(path.join(__dirname, "uploads")));

app.listen(3000, () => {
  console.log("Server running on port 3000");
});
